# -*- coding: utf-8 -*-
"""Stricker: Automatic differentiation: forward an backwards propagation algorithm 
    
Automatically generated by Colab.
"""

#Import libraries.
from abc import ABC, abstractmethod
import matplotlib.pyplot as plt
import math
import string
import Node

"""
Implement the ``create_graph`` function from infix notation. 
Each element has one of the two forms:  ``[Operation, Item]`` or ``[Item, Operation, Item]``.
Therefore input are lists of length <= 3.

``node_cache`` is used to avoid storing the same node multiple times.
``initialize_variables`` is used to assign numerical values to variable nodes
``forward`` 
``backward``

Gradient Descent (https://en.wikipedia.org/wiki/Gradient_descent)
``clean_gradients`` and the ``step`` function are based on compution:
$x_{new} = x - \lambda \frac{\partial f}{\partial x}.$


"""

class Executor:
    """
    Executes operations in a computation graph. It constructs the graph
    from a list of operations and supports forward and backward propagation.
    """

    def __init__(self, operations_list):
        """
        Initializes the Executor by constructing the computation graph.

        Args:
            operations_list (list): A list representing the operations to construct 
                                   the graph, in infix format. 
                                   The expression I want to transform into a node
        """
        self.forward_done  = False # Used for plotting
        self.backward_done = False # Used for plotting
        self.node_cache    = {}  # Dictionary storing nodes to avoid creating nodes twice.
        self.variables     = {} # Dictionary storing variable nodes: {'x': Node(...)}
        self.maxDepth      = 0 # Represents the depth of the graph
        self.create_graph(operations_list)
        self.layers = [[] for _ in range(self.maxDepth + 1)] # Default init
        self.populate_layers()

    def create_graph(self, operations_list, depth=0):
        """
        Recursively constructs the computation graph from an operation list.

        Args:
            operations_list (list or str or float): A nested list defining operations and operands,
                or a single operand (variable name or constant).
            depth (int): The depth of the node. Updated during recursion.

        Returns:
            Node: The root node of the graph/subgraph.
        """

        node = None
        self.maxDepth = max(self.maxDepth, depth)
        node_key = str(operations_list)

        ## TODO (iii)
        # Do not forget to merge nodes and to update depth when needed!
        # Hint: node.depth should store the maximum depth at which the node is encountered.
  
        # If the node has already been created, reuse it (merge) and update depth
        if node_key in self.node_cache:
            node = self.node_cache[node_key]
            # Update depth with the max depth
            node.depth = max(node.depth, depth)
            return node

        # Node = constant 
        if isinstance(operations_list, (int, float)):
            node = Node(output=operations_list, depth=depth)
        
        # Node = variable (string)
        elif isinstance(operations_list, str):
            node = Node(output=operations_list, depth=depth) #put placeholder in output
            # Store value of variables
            if operations_list not in self.variables:
                self.variables[operations_list] = node
        
        # Ricursive: list (operazions)
        elif isinstance(operations_list, list):
            
            # Unary operation: ["sin", x]
            if len(operations_list) == 2:    
                operation = operations_list[0]
                parent_right = self.create_graph(operations_list[1], depth + 1)
                node = Node(operation=operation, parent_right=parent_right, depth=depth)
            
            # Binary operation: [x, "+", y]
            elif len(operations_list) == 3:
                parent_left = self.create_graph(operations_list[0], depth + 1)
                operation = operations_list[1]
                parent_right = self.create_graph(operations_list[2], depth + 1)
                node = Node(operation=operation, parent_left=parent_left, parent_right=parent_right, depth=depth)


        # Store the node in the cache
        self.node_cache[node_key] = node
        return node

    def populate_layers(self):
        """
        Organizes nodes into layers based on their depth and determines the graph's width.
        create_graph() needs to have been executed before
        """
        for node in self.node_cache.values():
            self.layers[node.depth].append(node) #It adds node to the list corresponidng to its depth

        # Calculate max span of the graph. LS:width here does not mean how deeop (?)
        self.width = max(len(layer) for layer in self.layers) # Used for plotting

    def initialize_variables(self, variable_values):
        """
        Initializes all variable nodes with provided values.

        Args:
            variable_values (dict): A dictionary mapping variable names to their values.
        """
        ## TODO(iii)
        for variable_name, value in variable_values.items():
             if variable_name in self.variables:
                  self.variables[variable_name].output = value


    def forward(self):
        """
        Performs a forward pass through the graph, computing outputs for all nodes.

        Returns:
            float: The output of the root node of the graph.
        """
        self.forward_done = True # Used for plotting

        ## TODO(iii)
        for depth in range(self.maxDepth, -1, -1):
            for node in self.layers[depth]:
                node.forward()

        return self.layers[0][0].output


    def backward(self):
        """
        Performs a backward pass through the graph, propagating gradients.

        Returns:
            dict: A dictionary mapping variable names to their gradients.
        """
        self.backward_done = True # Used for plotting

        ## TODO(iii)        
        for depth in range(0,self.maxDepth+1):
            for node in self.layers[depth]:
                node.backward()


        return {key: self.variables[key].gradient for key in self.variables}

# Gradients
#------------------------------------------------------------------------------------------------
    def clean_gradients(self):
        """
        Resets all gradients in the graph to zero and sets the output node's gradient to one.
        """
        ## TODO (iiii)
        for node in self.node_cache.values():
           node.gradient = 0.0
           
        self.layers[0][0].gradient = 1
        


    def step(self, learning_rate):
        """
        Updates variable node outputs based on their gradients and the learning rate.

        Args:
            learning_rate (float): The learning rate for gradient descent.
        """
        ## TODO (iiii)
        for variable_name in self.variables:
            self.variables[variable_name].output -= learning_rate * self.variables[variable_name].gradient


    def gradient_descent(self, epochs, learning_rate):
        """
        Performs gradient descent to minimize the output node (loss) over a number of epochs.

        Args:
            epochs (int): The number of iterations to perform.
            learning_rate (float): The learning rate for gradient descent.

        Returns:
            dict: A dictionary mapping variable names to their optimized values.
        """
        for _ in range(epochs):
            self.clean_gradients()
            self.forward()
            self.backward()
            self.step(learning_rate)
        return {key: self.variables[key].output for key in self.variables}


# Visualization
#------------------------------------------------------------------------------------------------
    def plot_graph(self):
        """
        Plots the computation graph with numerical values from forward and backward passes.
        Green edges represent left operands, while red edges represent right operands.
        """
        points = {}
        edges = []
        operations = {}
        forward = {}
        backward = {}

        for i in range(len(self.layers) - 1, -1, -1):
            x = (len(self.layers) - i) / (len(self.layers) + 1)
            for j, node in enumerate(self.layers[i]):
                y = (j + 1) / (len(self.layers[i]) + 1)
                points[node.name] = (x, y)

                if node.operation_name:
                    operations[node.name] = node.operation_name

                if node.parent_left:
                    edges.append([node.parent_left.name, node.name, "green"])
                if node.parent_right:
                    edges.append([node.parent_right.name, node.name, "red"])

                if self.forward_done:
                    v = node.output
                    forward[node.name] = int(v) if v % 1 == 0 else round(v, 1)

                if self.backward_done:
                    v = node.gradient
                    backward[node.name] = int(v) if v % 1 == 0 else round(v, 1)

        plt.figure(figsize=(2 * self.maxDepth, 2 * self.width))

        for label, (x, y) in points.items():
            plt.scatter(x, y, color='gray')
            if self.forward_done:
                plt.text(x, y + 0.005, forward.get(label, ''), fontsize=12, ha='center', va='bottom', color='orange')
            if self.backward_done:
                plt.text(x, y - 0.01, backward.get(label, ''), fontsize=12, ha='center', va='top', color='blue')
            operation = operations.get(label, '')
            display_label = f"{label}({operation})" if operation else label
            plt.text(x - 0.01, y, display_label, fontsize=12, ha='right', va='center')

        for start, end, color in edges:
            x_start, y_start = points[start]
            x_end, y_end = points[end]
            plt.annotate(
                '',
                xy=(x_end, y_end),
                xytext=(x_start, y_start),
                arrowprops=dict(color=color, arrowstyle='->', lw=1.5, alpha=0.2)
            )

        plt.axis('off')
        plt.title("Computation Graph")
        plt.show()
